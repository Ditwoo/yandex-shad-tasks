## Домашнее задание №1

1. Написать программу, подсчитывающую в __M__ потоках сумму ряда **_sin(x)*cos(x)_**,
    где x пробегает диапазон от __-N__ до __N__,
    с шагом __step = 0.0001__

    #####sum = sin(-N) * cos(-N) + … + sin(N) * cos(N)

    При реализации не использовать блоки синхронизации и библиотеку __java.util.concurrent__ - _(package ua.yandex.sumofseries.threads)_
    При реализации использовать __ExecutorService__, и интерфейс Callable из библиотеки __java.util.concurrent__ - _(package ua.yandex.sumofseries.utilconcurrent)_
    Провести тестирование и определить, в скольких потоках оптимальнее считать сумму ряда (зависимость времени подсчета от числа потоков).

2. Реализовать параллельную версию алгоритма сортировки слиянием __(mergesort)__,
    в соответствии с алгоритмом, приведенным в разделе [27.3 Multithreaded merge sort](https://mitpress.mit.edu/sites/default/files/titles/content/9780262033848_sch_0001.pdf) - _(package ua.yandex.mergesort)_.

3. На основании шаблона [Producer/Consumer](http://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html) реализовать блокирующий [кольцевой буфер](https://en.wikipedia.org/wiki/Circular_buffer) на N элементов.
    Если буфер пуст, то читающие потоки должны ждать появления в нем элементов.
    Если буфер заполнен, то пишущие потоки должны ждать удаление элементов.
    При реализации не использовать библиотеку __java.util.concurrent__ - _(package ua.yandex.prodcons.threads)_
    При реализации использовать __ReentrantLock__ и __Condition__ из библиотеки __java.util.concurrent__ - _(package ua.yandex.prodcons.utilconcurrent)_.

4. Реализуйте пул потоков для фиксированного числа потоков (количество потоков в пуле задается в конструкторе пула).
    Проведите его тестирование с учетом того, что заданий может быть больше чем число свободных потоков.
    Описание [Thread pool pattern](https://en.wikipedia.org/wiki/Thread_pool).
    При реализации не использовать библиотеку __java.util.concurrent__ - _(package ua.yandex.threadpool)_.

5. Напишите __lock-free__ реализацию класса с методом __BigInteger next()__,
    который возвращает элементы последовательности: __[1, 2, 4, 8, 16, ...]__.
    Код должен корректно работать в многопоточной среде.
    Протестируйте на предмет отсутствия пропусков и дубликатов - _(package ua.yandex.lockfree)_.

6. У Вас имеется массив слов (строк) - __words__.
    Используя подход __Fork/Join__ напишите реализацию __WordCount__ подсчитывающую сколько раз каждое слов встречается в массиве _(package ua.yandex.fj)_.
    В результате у вас должна быть __Map<String, Integer> wordsCount__.
    При реализации используйте __ForkJoin Pool__.

7. У Вас есть класс __Bank__ с методом __transfer()__ для перевода денег с одного счета на другой в пределах банка - _(package ua.yandex.bank)_

```java
public class Bank {
    public void transfer(Account from, Account to, int amount) {
        atomic {
            from.withdraw(amount);
            to.deposit(amount);
        }
    }
}
```

К сожалению, в _Java_ отсутствует конструкция типа __atomic__ для выполнения транзакций.
Напишите свою реализация тела метода __transfer()__, которая могла бы работать в многопоточной среде (не используя синхронизацию на экземпляре класса __Bank__ и не блокируя транзакций с другими счетами).
Во время перевода денег со счета на счет, данные счета должны блокироваться. Подумайте, как при этом избежать deadlock-ов.

Выполните тестирование метода __transfer()__. Для этого:
 - Создайте несколько десятков (сотен) счетов и положите на них случайное количество денег.
 - Подсчитайте сколько денег есть всего в банке (сумма денег на всех счетах).
 - Запустите в нескольких тысячах потоков одновременные перевод случайных сумм денег со случайного счета на случайный счет (сумма на счету не может быть отрицательной)
 - Дождитесь окончания перевод и подсчитайте сколько денег есть всего в банке (сумма денег на всех счетах). Сумма денег в банке до переводов и после, должны совпадать.